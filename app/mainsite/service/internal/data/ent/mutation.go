// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/fxkt-tech/raiden/app/mainsite/service/internal/biz"
	"github.com/fxkt-tech/raiden/app/mainsite/service/internal/data/ent/predicate"
	"github.com/fxkt-tech/raiden/app/mainsite/service/internal/data/ent/rdmessage"
	"github.com/fxkt-tech/raiden/app/mainsite/service/internal/data/ent/rdmoment"
	"github.com/fxkt-tech/raiden/app/mainsite/service/internal/data/ent/rdrmomentsfollowing"
	"github.com/fxkt-tech/raiden/app/mainsite/service/internal/data/ent/rdruserfollowers"
	"github.com/fxkt-tech/raiden/app/mainsite/service/internal/data/ent/rdruserfollowing"
	"github.com/fxkt-tech/raiden/app/mainsite/service/internal/data/ent/rduser"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeRdMessage           = "RdMessage"
	TypeRdMoment            = "RdMoment"
	TypeRdRMomentsFollowing = "RdRMomentsFollowing"
	TypeRdRUserFollowers    = "RdRUserFollowers"
	TypeRdRUserFollowing    = "RdRUserFollowing"
	TypeRdUser              = "RdUser"
)

// RdMessageMutation represents an operation that mutates the RdMessage nodes in the graph.
type RdMessageMutation struct {
	config
	op            Op
	typ           string
	id            *int32
	sender_uid    *int32
	addsender_uid *int32
	recver_uid    *int32
	addrecver_uid *int32
	content       **biz.Content
	create_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*RdMessage, error)
	predicates    []predicate.RdMessage
}

var _ ent.Mutation = (*RdMessageMutation)(nil)

// rdmessageOption allows management of the mutation configuration using functional options.
type rdmessageOption func(*RdMessageMutation)

// newRdMessageMutation creates new mutation for the RdMessage entity.
func newRdMessageMutation(c config, op Op, opts ...rdmessageOption) *RdMessageMutation {
	m := &RdMessageMutation{
		config:        c,
		op:            op,
		typ:           TypeRdMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRdMessageID sets the ID field of the mutation.
func withRdMessageID(id int32) rdmessageOption {
	return func(m *RdMessageMutation) {
		var (
			err   error
			once  sync.Once
			value *RdMessage
		)
		m.oldValue = func(ctx context.Context) (*RdMessage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RdMessage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRdMessage sets the old RdMessage of the mutation.
func withRdMessage(node *RdMessage) rdmessageOption {
	return func(m *RdMessageMutation) {
		m.oldValue = func(context.Context) (*RdMessage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RdMessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RdMessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RdMessage entities.
func (m *RdMessageMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RdMessageMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RdMessageMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RdMessage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSenderUID sets the "sender_uid" field.
func (m *RdMessageMutation) SetSenderUID(i int32) {
	m.sender_uid = &i
	m.addsender_uid = nil
}

// SenderUID returns the value of the "sender_uid" field in the mutation.
func (m *RdMessageMutation) SenderUID() (r int32, exists bool) {
	v := m.sender_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderUID returns the old "sender_uid" field's value of the RdMessage entity.
// If the RdMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdMessageMutation) OldSenderUID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderUID: %w", err)
	}
	return oldValue.SenderUID, nil
}

// AddSenderUID adds i to the "sender_uid" field.
func (m *RdMessageMutation) AddSenderUID(i int32) {
	if m.addsender_uid != nil {
		*m.addsender_uid += i
	} else {
		m.addsender_uid = &i
	}
}

// AddedSenderUID returns the value that was added to the "sender_uid" field in this mutation.
func (m *RdMessageMutation) AddedSenderUID() (r int32, exists bool) {
	v := m.addsender_uid
	if v == nil {
		return
	}
	return *v, true
}

// ClearSenderUID clears the value of the "sender_uid" field.
func (m *RdMessageMutation) ClearSenderUID() {
	m.sender_uid = nil
	m.addsender_uid = nil
	m.clearedFields[rdmessage.FieldSenderUID] = struct{}{}
}

// SenderUIDCleared returns if the "sender_uid" field was cleared in this mutation.
func (m *RdMessageMutation) SenderUIDCleared() bool {
	_, ok := m.clearedFields[rdmessage.FieldSenderUID]
	return ok
}

// ResetSenderUID resets all changes to the "sender_uid" field.
func (m *RdMessageMutation) ResetSenderUID() {
	m.sender_uid = nil
	m.addsender_uid = nil
	delete(m.clearedFields, rdmessage.FieldSenderUID)
}

// SetRecverUID sets the "recver_uid" field.
func (m *RdMessageMutation) SetRecverUID(i int32) {
	m.recver_uid = &i
	m.addrecver_uid = nil
}

// RecverUID returns the value of the "recver_uid" field in the mutation.
func (m *RdMessageMutation) RecverUID() (r int32, exists bool) {
	v := m.recver_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldRecverUID returns the old "recver_uid" field's value of the RdMessage entity.
// If the RdMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdMessageMutation) OldRecverUID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecverUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecverUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecverUID: %w", err)
	}
	return oldValue.RecverUID, nil
}

// AddRecverUID adds i to the "recver_uid" field.
func (m *RdMessageMutation) AddRecverUID(i int32) {
	if m.addrecver_uid != nil {
		*m.addrecver_uid += i
	} else {
		m.addrecver_uid = &i
	}
}

// AddedRecverUID returns the value that was added to the "recver_uid" field in this mutation.
func (m *RdMessageMutation) AddedRecverUID() (r int32, exists bool) {
	v := m.addrecver_uid
	if v == nil {
		return
	}
	return *v, true
}

// ClearRecverUID clears the value of the "recver_uid" field.
func (m *RdMessageMutation) ClearRecverUID() {
	m.recver_uid = nil
	m.addrecver_uid = nil
	m.clearedFields[rdmessage.FieldRecverUID] = struct{}{}
}

// RecverUIDCleared returns if the "recver_uid" field was cleared in this mutation.
func (m *RdMessageMutation) RecverUIDCleared() bool {
	_, ok := m.clearedFields[rdmessage.FieldRecverUID]
	return ok
}

// ResetRecverUID resets all changes to the "recver_uid" field.
func (m *RdMessageMutation) ResetRecverUID() {
	m.recver_uid = nil
	m.addrecver_uid = nil
	delete(m.clearedFields, rdmessage.FieldRecverUID)
}

// SetContent sets the "content" field.
func (m *RdMessageMutation) SetContent(b *biz.Content) {
	m.content = &b
}

// Content returns the value of the "content" field in the mutation.
func (m *RdMessageMutation) Content() (r *biz.Content, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the RdMessage entity.
// If the RdMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdMessageMutation) OldContent(ctx context.Context) (v *biz.Content, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *RdMessageMutation) ResetContent() {
	m.content = nil
}

// SetCreateTime sets the "create_time" field.
func (m *RdMessageMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RdMessageMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the RdMessage entity.
// If the RdMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdMessageMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RdMessageMutation) ResetCreateTime() {
	m.create_time = nil
}

// Where appends a list predicates to the RdMessageMutation builder.
func (m *RdMessageMutation) Where(ps ...predicate.RdMessage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RdMessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RdMessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RdMessage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RdMessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RdMessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RdMessage).
func (m *RdMessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RdMessageMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.sender_uid != nil {
		fields = append(fields, rdmessage.FieldSenderUID)
	}
	if m.recver_uid != nil {
		fields = append(fields, rdmessage.FieldRecverUID)
	}
	if m.content != nil {
		fields = append(fields, rdmessage.FieldContent)
	}
	if m.create_time != nil {
		fields = append(fields, rdmessage.FieldCreateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RdMessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rdmessage.FieldSenderUID:
		return m.SenderUID()
	case rdmessage.FieldRecverUID:
		return m.RecverUID()
	case rdmessage.FieldContent:
		return m.Content()
	case rdmessage.FieldCreateTime:
		return m.CreateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RdMessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rdmessage.FieldSenderUID:
		return m.OldSenderUID(ctx)
	case rdmessage.FieldRecverUID:
		return m.OldRecverUID(ctx)
	case rdmessage.FieldContent:
		return m.OldContent(ctx)
	case rdmessage.FieldCreateTime:
		return m.OldCreateTime(ctx)
	}
	return nil, fmt.Errorf("unknown RdMessage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RdMessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rdmessage.FieldSenderUID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderUID(v)
		return nil
	case rdmessage.FieldRecverUID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecverUID(v)
		return nil
	case rdmessage.FieldContent:
		v, ok := value.(*biz.Content)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case rdmessage.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	}
	return fmt.Errorf("unknown RdMessage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RdMessageMutation) AddedFields() []string {
	var fields []string
	if m.addsender_uid != nil {
		fields = append(fields, rdmessage.FieldSenderUID)
	}
	if m.addrecver_uid != nil {
		fields = append(fields, rdmessage.FieldRecverUID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RdMessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rdmessage.FieldSenderUID:
		return m.AddedSenderUID()
	case rdmessage.FieldRecverUID:
		return m.AddedRecverUID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RdMessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rdmessage.FieldSenderUID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSenderUID(v)
		return nil
	case rdmessage.FieldRecverUID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecverUID(v)
		return nil
	}
	return fmt.Errorf("unknown RdMessage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RdMessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rdmessage.FieldSenderUID) {
		fields = append(fields, rdmessage.FieldSenderUID)
	}
	if m.FieldCleared(rdmessage.FieldRecverUID) {
		fields = append(fields, rdmessage.FieldRecverUID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RdMessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RdMessageMutation) ClearField(name string) error {
	switch name {
	case rdmessage.FieldSenderUID:
		m.ClearSenderUID()
		return nil
	case rdmessage.FieldRecverUID:
		m.ClearRecverUID()
		return nil
	}
	return fmt.Errorf("unknown RdMessage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RdMessageMutation) ResetField(name string) error {
	switch name {
	case rdmessage.FieldSenderUID:
		m.ResetSenderUID()
		return nil
	case rdmessage.FieldRecverUID:
		m.ResetRecverUID()
		return nil
	case rdmessage.FieldContent:
		m.ResetContent()
		return nil
	case rdmessage.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	}
	return fmt.Errorf("unknown RdMessage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RdMessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RdMessageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RdMessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RdMessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RdMessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RdMessageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RdMessageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RdMessage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RdMessageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RdMessage edge %s", name)
}

// RdMomentMutation represents an operation that mutates the RdMoment nodes in the graph.
type RdMomentMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	_type         *int32
	add_type      *int32
	by_uid        *int32
	addby_uid     *int32
	txt           *string
	imgs          *[]string
	appendimgs    []string
	status        *int32
	addstatus     *int32
	publish_time  *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*RdMoment, error)
	predicates    []predicate.RdMoment
}

var _ ent.Mutation = (*RdMomentMutation)(nil)

// rdmomentOption allows management of the mutation configuration using functional options.
type rdmomentOption func(*RdMomentMutation)

// newRdMomentMutation creates new mutation for the RdMoment entity.
func newRdMomentMutation(c config, op Op, opts ...rdmomentOption) *RdMomentMutation {
	m := &RdMomentMutation{
		config:        c,
		op:            op,
		typ:           TypeRdMoment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRdMomentID sets the ID field of the mutation.
func withRdMomentID(id int64) rdmomentOption {
	return func(m *RdMomentMutation) {
		var (
			err   error
			once  sync.Once
			value *RdMoment
		)
		m.oldValue = func(ctx context.Context) (*RdMoment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RdMoment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRdMoment sets the old RdMoment of the mutation.
func withRdMoment(node *RdMoment) rdmomentOption {
	return func(m *RdMomentMutation) {
		m.oldValue = func(context.Context) (*RdMoment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RdMomentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RdMomentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RdMoment entities.
func (m *RdMomentMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RdMomentMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RdMomentMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RdMoment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *RdMomentMutation) SetType(i int32) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *RdMomentMutation) GetType() (r int32, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the RdMoment entity.
// If the RdMoment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdMomentMutation) OldType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *RdMomentMutation) AddType(i int32) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *RdMomentMutation) AddedType() (r int32, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearType clears the value of the "type" field.
func (m *RdMomentMutation) ClearType() {
	m._type = nil
	m.add_type = nil
	m.clearedFields[rdmoment.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *RdMomentMutation) TypeCleared() bool {
	_, ok := m.clearedFields[rdmoment.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *RdMomentMutation) ResetType() {
	m._type = nil
	m.add_type = nil
	delete(m.clearedFields, rdmoment.FieldType)
}

// SetByUID sets the "by_uid" field.
func (m *RdMomentMutation) SetByUID(i int32) {
	m.by_uid = &i
	m.addby_uid = nil
}

// ByUID returns the value of the "by_uid" field in the mutation.
func (m *RdMomentMutation) ByUID() (r int32, exists bool) {
	v := m.by_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldByUID returns the old "by_uid" field's value of the RdMoment entity.
// If the RdMoment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdMomentMutation) OldByUID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldByUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldByUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldByUID: %w", err)
	}
	return oldValue.ByUID, nil
}

// AddByUID adds i to the "by_uid" field.
func (m *RdMomentMutation) AddByUID(i int32) {
	if m.addby_uid != nil {
		*m.addby_uid += i
	} else {
		m.addby_uid = &i
	}
}

// AddedByUID returns the value that was added to the "by_uid" field in this mutation.
func (m *RdMomentMutation) AddedByUID() (r int32, exists bool) {
	v := m.addby_uid
	if v == nil {
		return
	}
	return *v, true
}

// ClearByUID clears the value of the "by_uid" field.
func (m *RdMomentMutation) ClearByUID() {
	m.by_uid = nil
	m.addby_uid = nil
	m.clearedFields[rdmoment.FieldByUID] = struct{}{}
}

// ByUIDCleared returns if the "by_uid" field was cleared in this mutation.
func (m *RdMomentMutation) ByUIDCleared() bool {
	_, ok := m.clearedFields[rdmoment.FieldByUID]
	return ok
}

// ResetByUID resets all changes to the "by_uid" field.
func (m *RdMomentMutation) ResetByUID() {
	m.by_uid = nil
	m.addby_uid = nil
	delete(m.clearedFields, rdmoment.FieldByUID)
}

// SetTxt sets the "txt" field.
func (m *RdMomentMutation) SetTxt(s string) {
	m.txt = &s
}

// Txt returns the value of the "txt" field in the mutation.
func (m *RdMomentMutation) Txt() (r string, exists bool) {
	v := m.txt
	if v == nil {
		return
	}
	return *v, true
}

// OldTxt returns the old "txt" field's value of the RdMoment entity.
// If the RdMoment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdMomentMutation) OldTxt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTxt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTxt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxt: %w", err)
	}
	return oldValue.Txt, nil
}

// ResetTxt resets all changes to the "txt" field.
func (m *RdMomentMutation) ResetTxt() {
	m.txt = nil
}

// SetImgs sets the "imgs" field.
func (m *RdMomentMutation) SetImgs(s []string) {
	m.imgs = &s
	m.appendimgs = nil
}

// Imgs returns the value of the "imgs" field in the mutation.
func (m *RdMomentMutation) Imgs() (r []string, exists bool) {
	v := m.imgs
	if v == nil {
		return
	}
	return *v, true
}

// OldImgs returns the old "imgs" field's value of the RdMoment entity.
// If the RdMoment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdMomentMutation) OldImgs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImgs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImgs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImgs: %w", err)
	}
	return oldValue.Imgs, nil
}

// AppendImgs adds s to the "imgs" field.
func (m *RdMomentMutation) AppendImgs(s []string) {
	m.appendimgs = append(m.appendimgs, s...)
}

// AppendedImgs returns the list of values that were appended to the "imgs" field in this mutation.
func (m *RdMomentMutation) AppendedImgs() ([]string, bool) {
	if len(m.appendimgs) == 0 {
		return nil, false
	}
	return m.appendimgs, true
}

// ResetImgs resets all changes to the "imgs" field.
func (m *RdMomentMutation) ResetImgs() {
	m.imgs = nil
	m.appendimgs = nil
}

// SetStatus sets the "status" field.
func (m *RdMomentMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *RdMomentMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RdMoment entity.
// If the RdMoment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdMomentMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *RdMomentMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *RdMomentMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *RdMomentMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[rdmoment.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *RdMomentMutation) StatusCleared() bool {
	_, ok := m.clearedFields[rdmoment.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *RdMomentMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, rdmoment.FieldStatus)
}

// SetPublishTime sets the "publish_time" field.
func (m *RdMomentMutation) SetPublishTime(t time.Time) {
	m.publish_time = &t
}

// PublishTime returns the value of the "publish_time" field in the mutation.
func (m *RdMomentMutation) PublishTime() (r time.Time, exists bool) {
	v := m.publish_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishTime returns the old "publish_time" field's value of the RdMoment entity.
// If the RdMoment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdMomentMutation) OldPublishTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishTime: %w", err)
	}
	return oldValue.PublishTime, nil
}

// ResetPublishTime resets all changes to the "publish_time" field.
func (m *RdMomentMutation) ResetPublishTime() {
	m.publish_time = nil
}

// Where appends a list predicates to the RdMomentMutation builder.
func (m *RdMomentMutation) Where(ps ...predicate.RdMoment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RdMomentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RdMomentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RdMoment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RdMomentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RdMomentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RdMoment).
func (m *RdMomentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RdMomentMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._type != nil {
		fields = append(fields, rdmoment.FieldType)
	}
	if m.by_uid != nil {
		fields = append(fields, rdmoment.FieldByUID)
	}
	if m.txt != nil {
		fields = append(fields, rdmoment.FieldTxt)
	}
	if m.imgs != nil {
		fields = append(fields, rdmoment.FieldImgs)
	}
	if m.status != nil {
		fields = append(fields, rdmoment.FieldStatus)
	}
	if m.publish_time != nil {
		fields = append(fields, rdmoment.FieldPublishTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RdMomentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rdmoment.FieldType:
		return m.GetType()
	case rdmoment.FieldByUID:
		return m.ByUID()
	case rdmoment.FieldTxt:
		return m.Txt()
	case rdmoment.FieldImgs:
		return m.Imgs()
	case rdmoment.FieldStatus:
		return m.Status()
	case rdmoment.FieldPublishTime:
		return m.PublishTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RdMomentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rdmoment.FieldType:
		return m.OldType(ctx)
	case rdmoment.FieldByUID:
		return m.OldByUID(ctx)
	case rdmoment.FieldTxt:
		return m.OldTxt(ctx)
	case rdmoment.FieldImgs:
		return m.OldImgs(ctx)
	case rdmoment.FieldStatus:
		return m.OldStatus(ctx)
	case rdmoment.FieldPublishTime:
		return m.OldPublishTime(ctx)
	}
	return nil, fmt.Errorf("unknown RdMoment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RdMomentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rdmoment.FieldType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case rdmoment.FieldByUID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetByUID(v)
		return nil
	case rdmoment.FieldTxt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxt(v)
		return nil
	case rdmoment.FieldImgs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImgs(v)
		return nil
	case rdmoment.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case rdmoment.FieldPublishTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishTime(v)
		return nil
	}
	return fmt.Errorf("unknown RdMoment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RdMomentMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, rdmoment.FieldType)
	}
	if m.addby_uid != nil {
		fields = append(fields, rdmoment.FieldByUID)
	}
	if m.addstatus != nil {
		fields = append(fields, rdmoment.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RdMomentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rdmoment.FieldType:
		return m.AddedType()
	case rdmoment.FieldByUID:
		return m.AddedByUID()
	case rdmoment.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RdMomentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rdmoment.FieldType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case rdmoment.FieldByUID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddByUID(v)
		return nil
	case rdmoment.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown RdMoment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RdMomentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rdmoment.FieldType) {
		fields = append(fields, rdmoment.FieldType)
	}
	if m.FieldCleared(rdmoment.FieldByUID) {
		fields = append(fields, rdmoment.FieldByUID)
	}
	if m.FieldCleared(rdmoment.FieldStatus) {
		fields = append(fields, rdmoment.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RdMomentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RdMomentMutation) ClearField(name string) error {
	switch name {
	case rdmoment.FieldType:
		m.ClearType()
		return nil
	case rdmoment.FieldByUID:
		m.ClearByUID()
		return nil
	case rdmoment.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown RdMoment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RdMomentMutation) ResetField(name string) error {
	switch name {
	case rdmoment.FieldType:
		m.ResetType()
		return nil
	case rdmoment.FieldByUID:
		m.ResetByUID()
		return nil
	case rdmoment.FieldTxt:
		m.ResetTxt()
		return nil
	case rdmoment.FieldImgs:
		m.ResetImgs()
		return nil
	case rdmoment.FieldStatus:
		m.ResetStatus()
		return nil
	case rdmoment.FieldPublishTime:
		m.ResetPublishTime()
		return nil
	}
	return fmt.Errorf("unknown RdMoment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RdMomentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RdMomentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RdMomentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RdMomentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RdMomentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RdMomentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RdMomentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RdMoment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RdMomentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RdMoment edge %s", name)
}

// RdRMomentsFollowingMutation represents an operation that mutates the RdRMomentsFollowing nodes in the graph.
type RdRMomentsFollowingMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	moment_id      *int64
	addmoment_id   *int64
	moment_type    *int32
	addmoment_type *int32
	by_uid         *int32
	addby_uid      *int32
	for_uid        *int32
	addfor_uid     *int32
	txt            *string
	imgs           *[]string
	appendimgs     []string
	status         *int32
	addstatus      *int32
	publish_time   *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*RdRMomentsFollowing, error)
	predicates     []predicate.RdRMomentsFollowing
}

var _ ent.Mutation = (*RdRMomentsFollowingMutation)(nil)

// rdrmomentsfollowingOption allows management of the mutation configuration using functional options.
type rdrmomentsfollowingOption func(*RdRMomentsFollowingMutation)

// newRdRMomentsFollowingMutation creates new mutation for the RdRMomentsFollowing entity.
func newRdRMomentsFollowingMutation(c config, op Op, opts ...rdrmomentsfollowingOption) *RdRMomentsFollowingMutation {
	m := &RdRMomentsFollowingMutation{
		config:        c,
		op:            op,
		typ:           TypeRdRMomentsFollowing,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRdRMomentsFollowingID sets the ID field of the mutation.
func withRdRMomentsFollowingID(id int64) rdrmomentsfollowingOption {
	return func(m *RdRMomentsFollowingMutation) {
		var (
			err   error
			once  sync.Once
			value *RdRMomentsFollowing
		)
		m.oldValue = func(ctx context.Context) (*RdRMomentsFollowing, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RdRMomentsFollowing.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRdRMomentsFollowing sets the old RdRMomentsFollowing of the mutation.
func withRdRMomentsFollowing(node *RdRMomentsFollowing) rdrmomentsfollowingOption {
	return func(m *RdRMomentsFollowingMutation) {
		m.oldValue = func(context.Context) (*RdRMomentsFollowing, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RdRMomentsFollowingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RdRMomentsFollowingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RdRMomentsFollowing entities.
func (m *RdRMomentsFollowingMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RdRMomentsFollowingMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RdRMomentsFollowingMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RdRMomentsFollowing.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMomentID sets the "moment_id" field.
func (m *RdRMomentsFollowingMutation) SetMomentID(i int64) {
	m.moment_id = &i
	m.addmoment_id = nil
}

// MomentID returns the value of the "moment_id" field in the mutation.
func (m *RdRMomentsFollowingMutation) MomentID() (r int64, exists bool) {
	v := m.moment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMomentID returns the old "moment_id" field's value of the RdRMomentsFollowing entity.
// If the RdRMomentsFollowing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdRMomentsFollowingMutation) OldMomentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMomentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMomentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMomentID: %w", err)
	}
	return oldValue.MomentID, nil
}

// AddMomentID adds i to the "moment_id" field.
func (m *RdRMomentsFollowingMutation) AddMomentID(i int64) {
	if m.addmoment_id != nil {
		*m.addmoment_id += i
	} else {
		m.addmoment_id = &i
	}
}

// AddedMomentID returns the value that was added to the "moment_id" field in this mutation.
func (m *RdRMomentsFollowingMutation) AddedMomentID() (r int64, exists bool) {
	v := m.addmoment_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMomentID clears the value of the "moment_id" field.
func (m *RdRMomentsFollowingMutation) ClearMomentID() {
	m.moment_id = nil
	m.addmoment_id = nil
	m.clearedFields[rdrmomentsfollowing.FieldMomentID] = struct{}{}
}

// MomentIDCleared returns if the "moment_id" field was cleared in this mutation.
func (m *RdRMomentsFollowingMutation) MomentIDCleared() bool {
	_, ok := m.clearedFields[rdrmomentsfollowing.FieldMomentID]
	return ok
}

// ResetMomentID resets all changes to the "moment_id" field.
func (m *RdRMomentsFollowingMutation) ResetMomentID() {
	m.moment_id = nil
	m.addmoment_id = nil
	delete(m.clearedFields, rdrmomentsfollowing.FieldMomentID)
}

// SetMomentType sets the "moment_type" field.
func (m *RdRMomentsFollowingMutation) SetMomentType(i int32) {
	m.moment_type = &i
	m.addmoment_type = nil
}

// MomentType returns the value of the "moment_type" field in the mutation.
func (m *RdRMomentsFollowingMutation) MomentType() (r int32, exists bool) {
	v := m.moment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMomentType returns the old "moment_type" field's value of the RdRMomentsFollowing entity.
// If the RdRMomentsFollowing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdRMomentsFollowingMutation) OldMomentType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMomentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMomentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMomentType: %w", err)
	}
	return oldValue.MomentType, nil
}

// AddMomentType adds i to the "moment_type" field.
func (m *RdRMomentsFollowingMutation) AddMomentType(i int32) {
	if m.addmoment_type != nil {
		*m.addmoment_type += i
	} else {
		m.addmoment_type = &i
	}
}

// AddedMomentType returns the value that was added to the "moment_type" field in this mutation.
func (m *RdRMomentsFollowingMutation) AddedMomentType() (r int32, exists bool) {
	v := m.addmoment_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearMomentType clears the value of the "moment_type" field.
func (m *RdRMomentsFollowingMutation) ClearMomentType() {
	m.moment_type = nil
	m.addmoment_type = nil
	m.clearedFields[rdrmomentsfollowing.FieldMomentType] = struct{}{}
}

// MomentTypeCleared returns if the "moment_type" field was cleared in this mutation.
func (m *RdRMomentsFollowingMutation) MomentTypeCleared() bool {
	_, ok := m.clearedFields[rdrmomentsfollowing.FieldMomentType]
	return ok
}

// ResetMomentType resets all changes to the "moment_type" field.
func (m *RdRMomentsFollowingMutation) ResetMomentType() {
	m.moment_type = nil
	m.addmoment_type = nil
	delete(m.clearedFields, rdrmomentsfollowing.FieldMomentType)
}

// SetByUID sets the "by_uid" field.
func (m *RdRMomentsFollowingMutation) SetByUID(i int32) {
	m.by_uid = &i
	m.addby_uid = nil
}

// ByUID returns the value of the "by_uid" field in the mutation.
func (m *RdRMomentsFollowingMutation) ByUID() (r int32, exists bool) {
	v := m.by_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldByUID returns the old "by_uid" field's value of the RdRMomentsFollowing entity.
// If the RdRMomentsFollowing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdRMomentsFollowingMutation) OldByUID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldByUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldByUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldByUID: %w", err)
	}
	return oldValue.ByUID, nil
}

// AddByUID adds i to the "by_uid" field.
func (m *RdRMomentsFollowingMutation) AddByUID(i int32) {
	if m.addby_uid != nil {
		*m.addby_uid += i
	} else {
		m.addby_uid = &i
	}
}

// AddedByUID returns the value that was added to the "by_uid" field in this mutation.
func (m *RdRMomentsFollowingMutation) AddedByUID() (r int32, exists bool) {
	v := m.addby_uid
	if v == nil {
		return
	}
	return *v, true
}

// ClearByUID clears the value of the "by_uid" field.
func (m *RdRMomentsFollowingMutation) ClearByUID() {
	m.by_uid = nil
	m.addby_uid = nil
	m.clearedFields[rdrmomentsfollowing.FieldByUID] = struct{}{}
}

// ByUIDCleared returns if the "by_uid" field was cleared in this mutation.
func (m *RdRMomentsFollowingMutation) ByUIDCleared() bool {
	_, ok := m.clearedFields[rdrmomentsfollowing.FieldByUID]
	return ok
}

// ResetByUID resets all changes to the "by_uid" field.
func (m *RdRMomentsFollowingMutation) ResetByUID() {
	m.by_uid = nil
	m.addby_uid = nil
	delete(m.clearedFields, rdrmomentsfollowing.FieldByUID)
}

// SetForUID sets the "for_uid" field.
func (m *RdRMomentsFollowingMutation) SetForUID(i int32) {
	m.for_uid = &i
	m.addfor_uid = nil
}

// ForUID returns the value of the "for_uid" field in the mutation.
func (m *RdRMomentsFollowingMutation) ForUID() (r int32, exists bool) {
	v := m.for_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldForUID returns the old "for_uid" field's value of the RdRMomentsFollowing entity.
// If the RdRMomentsFollowing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdRMomentsFollowingMutation) OldForUID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForUID: %w", err)
	}
	return oldValue.ForUID, nil
}

// AddForUID adds i to the "for_uid" field.
func (m *RdRMomentsFollowingMutation) AddForUID(i int32) {
	if m.addfor_uid != nil {
		*m.addfor_uid += i
	} else {
		m.addfor_uid = &i
	}
}

// AddedForUID returns the value that was added to the "for_uid" field in this mutation.
func (m *RdRMomentsFollowingMutation) AddedForUID() (r int32, exists bool) {
	v := m.addfor_uid
	if v == nil {
		return
	}
	return *v, true
}

// ClearForUID clears the value of the "for_uid" field.
func (m *RdRMomentsFollowingMutation) ClearForUID() {
	m.for_uid = nil
	m.addfor_uid = nil
	m.clearedFields[rdrmomentsfollowing.FieldForUID] = struct{}{}
}

// ForUIDCleared returns if the "for_uid" field was cleared in this mutation.
func (m *RdRMomentsFollowingMutation) ForUIDCleared() bool {
	_, ok := m.clearedFields[rdrmomentsfollowing.FieldForUID]
	return ok
}

// ResetForUID resets all changes to the "for_uid" field.
func (m *RdRMomentsFollowingMutation) ResetForUID() {
	m.for_uid = nil
	m.addfor_uid = nil
	delete(m.clearedFields, rdrmomentsfollowing.FieldForUID)
}

// SetTxt sets the "txt" field.
func (m *RdRMomentsFollowingMutation) SetTxt(s string) {
	m.txt = &s
}

// Txt returns the value of the "txt" field in the mutation.
func (m *RdRMomentsFollowingMutation) Txt() (r string, exists bool) {
	v := m.txt
	if v == nil {
		return
	}
	return *v, true
}

// OldTxt returns the old "txt" field's value of the RdRMomentsFollowing entity.
// If the RdRMomentsFollowing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdRMomentsFollowingMutation) OldTxt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTxt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTxt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxt: %w", err)
	}
	return oldValue.Txt, nil
}

// ResetTxt resets all changes to the "txt" field.
func (m *RdRMomentsFollowingMutation) ResetTxt() {
	m.txt = nil
}

// SetImgs sets the "imgs" field.
func (m *RdRMomentsFollowingMutation) SetImgs(s []string) {
	m.imgs = &s
	m.appendimgs = nil
}

// Imgs returns the value of the "imgs" field in the mutation.
func (m *RdRMomentsFollowingMutation) Imgs() (r []string, exists bool) {
	v := m.imgs
	if v == nil {
		return
	}
	return *v, true
}

// OldImgs returns the old "imgs" field's value of the RdRMomentsFollowing entity.
// If the RdRMomentsFollowing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdRMomentsFollowingMutation) OldImgs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImgs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImgs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImgs: %w", err)
	}
	return oldValue.Imgs, nil
}

// AppendImgs adds s to the "imgs" field.
func (m *RdRMomentsFollowingMutation) AppendImgs(s []string) {
	m.appendimgs = append(m.appendimgs, s...)
}

// AppendedImgs returns the list of values that were appended to the "imgs" field in this mutation.
func (m *RdRMomentsFollowingMutation) AppendedImgs() ([]string, bool) {
	if len(m.appendimgs) == 0 {
		return nil, false
	}
	return m.appendimgs, true
}

// ResetImgs resets all changes to the "imgs" field.
func (m *RdRMomentsFollowingMutation) ResetImgs() {
	m.imgs = nil
	m.appendimgs = nil
}

// SetStatus sets the "status" field.
func (m *RdRMomentsFollowingMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *RdRMomentsFollowingMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RdRMomentsFollowing entity.
// If the RdRMomentsFollowing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdRMomentsFollowingMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *RdRMomentsFollowingMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *RdRMomentsFollowingMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *RdRMomentsFollowingMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[rdrmomentsfollowing.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *RdRMomentsFollowingMutation) StatusCleared() bool {
	_, ok := m.clearedFields[rdrmomentsfollowing.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *RdRMomentsFollowingMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, rdrmomentsfollowing.FieldStatus)
}

// SetPublishTime sets the "publish_time" field.
func (m *RdRMomentsFollowingMutation) SetPublishTime(t time.Time) {
	m.publish_time = &t
}

// PublishTime returns the value of the "publish_time" field in the mutation.
func (m *RdRMomentsFollowingMutation) PublishTime() (r time.Time, exists bool) {
	v := m.publish_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishTime returns the old "publish_time" field's value of the RdRMomentsFollowing entity.
// If the RdRMomentsFollowing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdRMomentsFollowingMutation) OldPublishTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishTime: %w", err)
	}
	return oldValue.PublishTime, nil
}

// ResetPublishTime resets all changes to the "publish_time" field.
func (m *RdRMomentsFollowingMutation) ResetPublishTime() {
	m.publish_time = nil
}

// Where appends a list predicates to the RdRMomentsFollowingMutation builder.
func (m *RdRMomentsFollowingMutation) Where(ps ...predicate.RdRMomentsFollowing) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RdRMomentsFollowingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RdRMomentsFollowingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RdRMomentsFollowing, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RdRMomentsFollowingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RdRMomentsFollowingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RdRMomentsFollowing).
func (m *RdRMomentsFollowingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RdRMomentsFollowingMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.moment_id != nil {
		fields = append(fields, rdrmomentsfollowing.FieldMomentID)
	}
	if m.moment_type != nil {
		fields = append(fields, rdrmomentsfollowing.FieldMomentType)
	}
	if m.by_uid != nil {
		fields = append(fields, rdrmomentsfollowing.FieldByUID)
	}
	if m.for_uid != nil {
		fields = append(fields, rdrmomentsfollowing.FieldForUID)
	}
	if m.txt != nil {
		fields = append(fields, rdrmomentsfollowing.FieldTxt)
	}
	if m.imgs != nil {
		fields = append(fields, rdrmomentsfollowing.FieldImgs)
	}
	if m.status != nil {
		fields = append(fields, rdrmomentsfollowing.FieldStatus)
	}
	if m.publish_time != nil {
		fields = append(fields, rdrmomentsfollowing.FieldPublishTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RdRMomentsFollowingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rdrmomentsfollowing.FieldMomentID:
		return m.MomentID()
	case rdrmomentsfollowing.FieldMomentType:
		return m.MomentType()
	case rdrmomentsfollowing.FieldByUID:
		return m.ByUID()
	case rdrmomentsfollowing.FieldForUID:
		return m.ForUID()
	case rdrmomentsfollowing.FieldTxt:
		return m.Txt()
	case rdrmomentsfollowing.FieldImgs:
		return m.Imgs()
	case rdrmomentsfollowing.FieldStatus:
		return m.Status()
	case rdrmomentsfollowing.FieldPublishTime:
		return m.PublishTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RdRMomentsFollowingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rdrmomentsfollowing.FieldMomentID:
		return m.OldMomentID(ctx)
	case rdrmomentsfollowing.FieldMomentType:
		return m.OldMomentType(ctx)
	case rdrmomentsfollowing.FieldByUID:
		return m.OldByUID(ctx)
	case rdrmomentsfollowing.FieldForUID:
		return m.OldForUID(ctx)
	case rdrmomentsfollowing.FieldTxt:
		return m.OldTxt(ctx)
	case rdrmomentsfollowing.FieldImgs:
		return m.OldImgs(ctx)
	case rdrmomentsfollowing.FieldStatus:
		return m.OldStatus(ctx)
	case rdrmomentsfollowing.FieldPublishTime:
		return m.OldPublishTime(ctx)
	}
	return nil, fmt.Errorf("unknown RdRMomentsFollowing field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RdRMomentsFollowingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rdrmomentsfollowing.FieldMomentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMomentID(v)
		return nil
	case rdrmomentsfollowing.FieldMomentType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMomentType(v)
		return nil
	case rdrmomentsfollowing.FieldByUID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetByUID(v)
		return nil
	case rdrmomentsfollowing.FieldForUID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForUID(v)
		return nil
	case rdrmomentsfollowing.FieldTxt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxt(v)
		return nil
	case rdrmomentsfollowing.FieldImgs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImgs(v)
		return nil
	case rdrmomentsfollowing.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case rdrmomentsfollowing.FieldPublishTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishTime(v)
		return nil
	}
	return fmt.Errorf("unknown RdRMomentsFollowing field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RdRMomentsFollowingMutation) AddedFields() []string {
	var fields []string
	if m.addmoment_id != nil {
		fields = append(fields, rdrmomentsfollowing.FieldMomentID)
	}
	if m.addmoment_type != nil {
		fields = append(fields, rdrmomentsfollowing.FieldMomentType)
	}
	if m.addby_uid != nil {
		fields = append(fields, rdrmomentsfollowing.FieldByUID)
	}
	if m.addfor_uid != nil {
		fields = append(fields, rdrmomentsfollowing.FieldForUID)
	}
	if m.addstatus != nil {
		fields = append(fields, rdrmomentsfollowing.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RdRMomentsFollowingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rdrmomentsfollowing.FieldMomentID:
		return m.AddedMomentID()
	case rdrmomentsfollowing.FieldMomentType:
		return m.AddedMomentType()
	case rdrmomentsfollowing.FieldByUID:
		return m.AddedByUID()
	case rdrmomentsfollowing.FieldForUID:
		return m.AddedForUID()
	case rdrmomentsfollowing.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RdRMomentsFollowingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rdrmomentsfollowing.FieldMomentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMomentID(v)
		return nil
	case rdrmomentsfollowing.FieldMomentType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMomentType(v)
		return nil
	case rdrmomentsfollowing.FieldByUID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddByUID(v)
		return nil
	case rdrmomentsfollowing.FieldForUID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddForUID(v)
		return nil
	case rdrmomentsfollowing.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown RdRMomentsFollowing numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RdRMomentsFollowingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rdrmomentsfollowing.FieldMomentID) {
		fields = append(fields, rdrmomentsfollowing.FieldMomentID)
	}
	if m.FieldCleared(rdrmomentsfollowing.FieldMomentType) {
		fields = append(fields, rdrmomentsfollowing.FieldMomentType)
	}
	if m.FieldCleared(rdrmomentsfollowing.FieldByUID) {
		fields = append(fields, rdrmomentsfollowing.FieldByUID)
	}
	if m.FieldCleared(rdrmomentsfollowing.FieldForUID) {
		fields = append(fields, rdrmomentsfollowing.FieldForUID)
	}
	if m.FieldCleared(rdrmomentsfollowing.FieldStatus) {
		fields = append(fields, rdrmomentsfollowing.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RdRMomentsFollowingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RdRMomentsFollowingMutation) ClearField(name string) error {
	switch name {
	case rdrmomentsfollowing.FieldMomentID:
		m.ClearMomentID()
		return nil
	case rdrmomentsfollowing.FieldMomentType:
		m.ClearMomentType()
		return nil
	case rdrmomentsfollowing.FieldByUID:
		m.ClearByUID()
		return nil
	case rdrmomentsfollowing.FieldForUID:
		m.ClearForUID()
		return nil
	case rdrmomentsfollowing.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown RdRMomentsFollowing nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RdRMomentsFollowingMutation) ResetField(name string) error {
	switch name {
	case rdrmomentsfollowing.FieldMomentID:
		m.ResetMomentID()
		return nil
	case rdrmomentsfollowing.FieldMomentType:
		m.ResetMomentType()
		return nil
	case rdrmomentsfollowing.FieldByUID:
		m.ResetByUID()
		return nil
	case rdrmomentsfollowing.FieldForUID:
		m.ResetForUID()
		return nil
	case rdrmomentsfollowing.FieldTxt:
		m.ResetTxt()
		return nil
	case rdrmomentsfollowing.FieldImgs:
		m.ResetImgs()
		return nil
	case rdrmomentsfollowing.FieldStatus:
		m.ResetStatus()
		return nil
	case rdrmomentsfollowing.FieldPublishTime:
		m.ResetPublishTime()
		return nil
	}
	return fmt.Errorf("unknown RdRMomentsFollowing field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RdRMomentsFollowingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RdRMomentsFollowingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RdRMomentsFollowingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RdRMomentsFollowingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RdRMomentsFollowingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RdRMomentsFollowingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RdRMomentsFollowingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RdRMomentsFollowing unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RdRMomentsFollowingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RdRMomentsFollowing edge %s", name)
}

// RdRUserFollowersMutation represents an operation that mutates the RdRUserFollowers nodes in the graph.
type RdRUserFollowersMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	uid              *int32
	adduid           *int32
	followers_uid    *int32
	addfollowers_uid *int32
	create_time      *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*RdRUserFollowers, error)
	predicates       []predicate.RdRUserFollowers
}

var _ ent.Mutation = (*RdRUserFollowersMutation)(nil)

// rdruserfollowersOption allows management of the mutation configuration using functional options.
type rdruserfollowersOption func(*RdRUserFollowersMutation)

// newRdRUserFollowersMutation creates new mutation for the RdRUserFollowers entity.
func newRdRUserFollowersMutation(c config, op Op, opts ...rdruserfollowersOption) *RdRUserFollowersMutation {
	m := &RdRUserFollowersMutation{
		config:        c,
		op:            op,
		typ:           TypeRdRUserFollowers,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRdRUserFollowersID sets the ID field of the mutation.
func withRdRUserFollowersID(id int64) rdruserfollowersOption {
	return func(m *RdRUserFollowersMutation) {
		var (
			err   error
			once  sync.Once
			value *RdRUserFollowers
		)
		m.oldValue = func(ctx context.Context) (*RdRUserFollowers, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RdRUserFollowers.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRdRUserFollowers sets the old RdRUserFollowers of the mutation.
func withRdRUserFollowers(node *RdRUserFollowers) rdruserfollowersOption {
	return func(m *RdRUserFollowersMutation) {
		m.oldValue = func(context.Context) (*RdRUserFollowers, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RdRUserFollowersMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RdRUserFollowersMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RdRUserFollowers entities.
func (m *RdRUserFollowersMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RdRUserFollowersMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RdRUserFollowersMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RdRUserFollowers.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *RdRUserFollowersMutation) SetUID(i int32) {
	m.uid = &i
	m.adduid = nil
}

// UID returns the value of the "uid" field in the mutation.
func (m *RdRUserFollowersMutation) UID() (r int32, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the RdRUserFollowers entity.
// If the RdRUserFollowers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdRUserFollowersMutation) OldUID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// AddUID adds i to the "uid" field.
func (m *RdRUserFollowersMutation) AddUID(i int32) {
	if m.adduid != nil {
		*m.adduid += i
	} else {
		m.adduid = &i
	}
}

// AddedUID returns the value that was added to the "uid" field in this mutation.
func (m *RdRUserFollowersMutation) AddedUID() (r int32, exists bool) {
	v := m.adduid
	if v == nil {
		return
	}
	return *v, true
}

// ClearUID clears the value of the "uid" field.
func (m *RdRUserFollowersMutation) ClearUID() {
	m.uid = nil
	m.adduid = nil
	m.clearedFields[rdruserfollowers.FieldUID] = struct{}{}
}

// UIDCleared returns if the "uid" field was cleared in this mutation.
func (m *RdRUserFollowersMutation) UIDCleared() bool {
	_, ok := m.clearedFields[rdruserfollowers.FieldUID]
	return ok
}

// ResetUID resets all changes to the "uid" field.
func (m *RdRUserFollowersMutation) ResetUID() {
	m.uid = nil
	m.adduid = nil
	delete(m.clearedFields, rdruserfollowers.FieldUID)
}

// SetFollowersUID sets the "followers_uid" field.
func (m *RdRUserFollowersMutation) SetFollowersUID(i int32) {
	m.followers_uid = &i
	m.addfollowers_uid = nil
}

// FollowersUID returns the value of the "followers_uid" field in the mutation.
func (m *RdRUserFollowersMutation) FollowersUID() (r int32, exists bool) {
	v := m.followers_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowersUID returns the old "followers_uid" field's value of the RdRUserFollowers entity.
// If the RdRUserFollowers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdRUserFollowersMutation) OldFollowersUID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowersUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowersUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowersUID: %w", err)
	}
	return oldValue.FollowersUID, nil
}

// AddFollowersUID adds i to the "followers_uid" field.
func (m *RdRUserFollowersMutation) AddFollowersUID(i int32) {
	if m.addfollowers_uid != nil {
		*m.addfollowers_uid += i
	} else {
		m.addfollowers_uid = &i
	}
}

// AddedFollowersUID returns the value that was added to the "followers_uid" field in this mutation.
func (m *RdRUserFollowersMutation) AddedFollowersUID() (r int32, exists bool) {
	v := m.addfollowers_uid
	if v == nil {
		return
	}
	return *v, true
}

// ClearFollowersUID clears the value of the "followers_uid" field.
func (m *RdRUserFollowersMutation) ClearFollowersUID() {
	m.followers_uid = nil
	m.addfollowers_uid = nil
	m.clearedFields[rdruserfollowers.FieldFollowersUID] = struct{}{}
}

// FollowersUIDCleared returns if the "followers_uid" field was cleared in this mutation.
func (m *RdRUserFollowersMutation) FollowersUIDCleared() bool {
	_, ok := m.clearedFields[rdruserfollowers.FieldFollowersUID]
	return ok
}

// ResetFollowersUID resets all changes to the "followers_uid" field.
func (m *RdRUserFollowersMutation) ResetFollowersUID() {
	m.followers_uid = nil
	m.addfollowers_uid = nil
	delete(m.clearedFields, rdruserfollowers.FieldFollowersUID)
}

// SetCreateTime sets the "create_time" field.
func (m *RdRUserFollowersMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RdRUserFollowersMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the RdRUserFollowers entity.
// If the RdRUserFollowers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdRUserFollowersMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RdRUserFollowersMutation) ResetCreateTime() {
	m.create_time = nil
}

// Where appends a list predicates to the RdRUserFollowersMutation builder.
func (m *RdRUserFollowersMutation) Where(ps ...predicate.RdRUserFollowers) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RdRUserFollowersMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RdRUserFollowersMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RdRUserFollowers, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RdRUserFollowersMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RdRUserFollowersMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RdRUserFollowers).
func (m *RdRUserFollowersMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RdRUserFollowersMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.uid != nil {
		fields = append(fields, rdruserfollowers.FieldUID)
	}
	if m.followers_uid != nil {
		fields = append(fields, rdruserfollowers.FieldFollowersUID)
	}
	if m.create_time != nil {
		fields = append(fields, rdruserfollowers.FieldCreateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RdRUserFollowersMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rdruserfollowers.FieldUID:
		return m.UID()
	case rdruserfollowers.FieldFollowersUID:
		return m.FollowersUID()
	case rdruserfollowers.FieldCreateTime:
		return m.CreateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RdRUserFollowersMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rdruserfollowers.FieldUID:
		return m.OldUID(ctx)
	case rdruserfollowers.FieldFollowersUID:
		return m.OldFollowersUID(ctx)
	case rdruserfollowers.FieldCreateTime:
		return m.OldCreateTime(ctx)
	}
	return nil, fmt.Errorf("unknown RdRUserFollowers field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RdRUserFollowersMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rdruserfollowers.FieldUID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case rdruserfollowers.FieldFollowersUID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowersUID(v)
		return nil
	case rdruserfollowers.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	}
	return fmt.Errorf("unknown RdRUserFollowers field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RdRUserFollowersMutation) AddedFields() []string {
	var fields []string
	if m.adduid != nil {
		fields = append(fields, rdruserfollowers.FieldUID)
	}
	if m.addfollowers_uid != nil {
		fields = append(fields, rdruserfollowers.FieldFollowersUID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RdRUserFollowersMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rdruserfollowers.FieldUID:
		return m.AddedUID()
	case rdruserfollowers.FieldFollowersUID:
		return m.AddedFollowersUID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RdRUserFollowersMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rdruserfollowers.FieldUID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUID(v)
		return nil
	case rdruserfollowers.FieldFollowersUID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFollowersUID(v)
		return nil
	}
	return fmt.Errorf("unknown RdRUserFollowers numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RdRUserFollowersMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rdruserfollowers.FieldUID) {
		fields = append(fields, rdruserfollowers.FieldUID)
	}
	if m.FieldCleared(rdruserfollowers.FieldFollowersUID) {
		fields = append(fields, rdruserfollowers.FieldFollowersUID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RdRUserFollowersMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RdRUserFollowersMutation) ClearField(name string) error {
	switch name {
	case rdruserfollowers.FieldUID:
		m.ClearUID()
		return nil
	case rdruserfollowers.FieldFollowersUID:
		m.ClearFollowersUID()
		return nil
	}
	return fmt.Errorf("unknown RdRUserFollowers nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RdRUserFollowersMutation) ResetField(name string) error {
	switch name {
	case rdruserfollowers.FieldUID:
		m.ResetUID()
		return nil
	case rdruserfollowers.FieldFollowersUID:
		m.ResetFollowersUID()
		return nil
	case rdruserfollowers.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	}
	return fmt.Errorf("unknown RdRUserFollowers field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RdRUserFollowersMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RdRUserFollowersMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RdRUserFollowersMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RdRUserFollowersMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RdRUserFollowersMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RdRUserFollowersMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RdRUserFollowersMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RdRUserFollowers unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RdRUserFollowersMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RdRUserFollowers edge %s", name)
}

// RdRUserFollowingMutation represents an operation that mutates the RdRUserFollowing nodes in the graph.
type RdRUserFollowingMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	uid              *int32
	adduid           *int32
	following_uid    *int32
	addfollowing_uid *int32
	create_time      *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*RdRUserFollowing, error)
	predicates       []predicate.RdRUserFollowing
}

var _ ent.Mutation = (*RdRUserFollowingMutation)(nil)

// rdruserfollowingOption allows management of the mutation configuration using functional options.
type rdruserfollowingOption func(*RdRUserFollowingMutation)

// newRdRUserFollowingMutation creates new mutation for the RdRUserFollowing entity.
func newRdRUserFollowingMutation(c config, op Op, opts ...rdruserfollowingOption) *RdRUserFollowingMutation {
	m := &RdRUserFollowingMutation{
		config:        c,
		op:            op,
		typ:           TypeRdRUserFollowing,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRdRUserFollowingID sets the ID field of the mutation.
func withRdRUserFollowingID(id int64) rdruserfollowingOption {
	return func(m *RdRUserFollowingMutation) {
		var (
			err   error
			once  sync.Once
			value *RdRUserFollowing
		)
		m.oldValue = func(ctx context.Context) (*RdRUserFollowing, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RdRUserFollowing.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRdRUserFollowing sets the old RdRUserFollowing of the mutation.
func withRdRUserFollowing(node *RdRUserFollowing) rdruserfollowingOption {
	return func(m *RdRUserFollowingMutation) {
		m.oldValue = func(context.Context) (*RdRUserFollowing, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RdRUserFollowingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RdRUserFollowingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RdRUserFollowing entities.
func (m *RdRUserFollowingMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RdRUserFollowingMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RdRUserFollowingMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RdRUserFollowing.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUID sets the "uid" field.
func (m *RdRUserFollowingMutation) SetUID(i int32) {
	m.uid = &i
	m.adduid = nil
}

// UID returns the value of the "uid" field in the mutation.
func (m *RdRUserFollowingMutation) UID() (r int32, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the RdRUserFollowing entity.
// If the RdRUserFollowing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdRUserFollowingMutation) OldUID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// AddUID adds i to the "uid" field.
func (m *RdRUserFollowingMutation) AddUID(i int32) {
	if m.adduid != nil {
		*m.adduid += i
	} else {
		m.adduid = &i
	}
}

// AddedUID returns the value that was added to the "uid" field in this mutation.
func (m *RdRUserFollowingMutation) AddedUID() (r int32, exists bool) {
	v := m.adduid
	if v == nil {
		return
	}
	return *v, true
}

// ClearUID clears the value of the "uid" field.
func (m *RdRUserFollowingMutation) ClearUID() {
	m.uid = nil
	m.adduid = nil
	m.clearedFields[rdruserfollowing.FieldUID] = struct{}{}
}

// UIDCleared returns if the "uid" field was cleared in this mutation.
func (m *RdRUserFollowingMutation) UIDCleared() bool {
	_, ok := m.clearedFields[rdruserfollowing.FieldUID]
	return ok
}

// ResetUID resets all changes to the "uid" field.
func (m *RdRUserFollowingMutation) ResetUID() {
	m.uid = nil
	m.adduid = nil
	delete(m.clearedFields, rdruserfollowing.FieldUID)
}

// SetFollowingUID sets the "following_uid" field.
func (m *RdRUserFollowingMutation) SetFollowingUID(i int32) {
	m.following_uid = &i
	m.addfollowing_uid = nil
}

// FollowingUID returns the value of the "following_uid" field in the mutation.
func (m *RdRUserFollowingMutation) FollowingUID() (r int32, exists bool) {
	v := m.following_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowingUID returns the old "following_uid" field's value of the RdRUserFollowing entity.
// If the RdRUserFollowing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdRUserFollowingMutation) OldFollowingUID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowingUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowingUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowingUID: %w", err)
	}
	return oldValue.FollowingUID, nil
}

// AddFollowingUID adds i to the "following_uid" field.
func (m *RdRUserFollowingMutation) AddFollowingUID(i int32) {
	if m.addfollowing_uid != nil {
		*m.addfollowing_uid += i
	} else {
		m.addfollowing_uid = &i
	}
}

// AddedFollowingUID returns the value that was added to the "following_uid" field in this mutation.
func (m *RdRUserFollowingMutation) AddedFollowingUID() (r int32, exists bool) {
	v := m.addfollowing_uid
	if v == nil {
		return
	}
	return *v, true
}

// ClearFollowingUID clears the value of the "following_uid" field.
func (m *RdRUserFollowingMutation) ClearFollowingUID() {
	m.following_uid = nil
	m.addfollowing_uid = nil
	m.clearedFields[rdruserfollowing.FieldFollowingUID] = struct{}{}
}

// FollowingUIDCleared returns if the "following_uid" field was cleared in this mutation.
func (m *RdRUserFollowingMutation) FollowingUIDCleared() bool {
	_, ok := m.clearedFields[rdruserfollowing.FieldFollowingUID]
	return ok
}

// ResetFollowingUID resets all changes to the "following_uid" field.
func (m *RdRUserFollowingMutation) ResetFollowingUID() {
	m.following_uid = nil
	m.addfollowing_uid = nil
	delete(m.clearedFields, rdruserfollowing.FieldFollowingUID)
}

// SetCreateTime sets the "create_time" field.
func (m *RdRUserFollowingMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RdRUserFollowingMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the RdRUserFollowing entity.
// If the RdRUserFollowing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdRUserFollowingMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RdRUserFollowingMutation) ResetCreateTime() {
	m.create_time = nil
}

// Where appends a list predicates to the RdRUserFollowingMutation builder.
func (m *RdRUserFollowingMutation) Where(ps ...predicate.RdRUserFollowing) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RdRUserFollowingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RdRUserFollowingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RdRUserFollowing, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RdRUserFollowingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RdRUserFollowingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RdRUserFollowing).
func (m *RdRUserFollowingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RdRUserFollowingMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.uid != nil {
		fields = append(fields, rdruserfollowing.FieldUID)
	}
	if m.following_uid != nil {
		fields = append(fields, rdruserfollowing.FieldFollowingUID)
	}
	if m.create_time != nil {
		fields = append(fields, rdruserfollowing.FieldCreateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RdRUserFollowingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rdruserfollowing.FieldUID:
		return m.UID()
	case rdruserfollowing.FieldFollowingUID:
		return m.FollowingUID()
	case rdruserfollowing.FieldCreateTime:
		return m.CreateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RdRUserFollowingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rdruserfollowing.FieldUID:
		return m.OldUID(ctx)
	case rdruserfollowing.FieldFollowingUID:
		return m.OldFollowingUID(ctx)
	case rdruserfollowing.FieldCreateTime:
		return m.OldCreateTime(ctx)
	}
	return nil, fmt.Errorf("unknown RdRUserFollowing field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RdRUserFollowingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rdruserfollowing.FieldUID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case rdruserfollowing.FieldFollowingUID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowingUID(v)
		return nil
	case rdruserfollowing.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	}
	return fmt.Errorf("unknown RdRUserFollowing field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RdRUserFollowingMutation) AddedFields() []string {
	var fields []string
	if m.adduid != nil {
		fields = append(fields, rdruserfollowing.FieldUID)
	}
	if m.addfollowing_uid != nil {
		fields = append(fields, rdruserfollowing.FieldFollowingUID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RdRUserFollowingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rdruserfollowing.FieldUID:
		return m.AddedUID()
	case rdruserfollowing.FieldFollowingUID:
		return m.AddedFollowingUID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RdRUserFollowingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rdruserfollowing.FieldUID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUID(v)
		return nil
	case rdruserfollowing.FieldFollowingUID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFollowingUID(v)
		return nil
	}
	return fmt.Errorf("unknown RdRUserFollowing numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RdRUserFollowingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rdruserfollowing.FieldUID) {
		fields = append(fields, rdruserfollowing.FieldUID)
	}
	if m.FieldCleared(rdruserfollowing.FieldFollowingUID) {
		fields = append(fields, rdruserfollowing.FieldFollowingUID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RdRUserFollowingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RdRUserFollowingMutation) ClearField(name string) error {
	switch name {
	case rdruserfollowing.FieldUID:
		m.ClearUID()
		return nil
	case rdruserfollowing.FieldFollowingUID:
		m.ClearFollowingUID()
		return nil
	}
	return fmt.Errorf("unknown RdRUserFollowing nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RdRUserFollowingMutation) ResetField(name string) error {
	switch name {
	case rdruserfollowing.FieldUID:
		m.ResetUID()
		return nil
	case rdruserfollowing.FieldFollowingUID:
		m.ResetFollowingUID()
		return nil
	case rdruserfollowing.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	}
	return fmt.Errorf("unknown RdRUserFollowing field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RdRUserFollowingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RdRUserFollowingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RdRUserFollowingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RdRUserFollowingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RdRUserFollowingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RdRUserFollowingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RdRUserFollowingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RdRUserFollowing unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RdRUserFollowingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RdRUserFollowing edge %s", name)
}

// RdUserMutation represents an operation that mutates the RdUser nodes in the graph.
type RdUserMutation struct {
	config
	op            Op
	typ           string
	id            *int32
	nick          *string
	status        *int32
	addstatus     *int32
	create_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*RdUser, error)
	predicates    []predicate.RdUser
}

var _ ent.Mutation = (*RdUserMutation)(nil)

// rduserOption allows management of the mutation configuration using functional options.
type rduserOption func(*RdUserMutation)

// newRdUserMutation creates new mutation for the RdUser entity.
func newRdUserMutation(c config, op Op, opts ...rduserOption) *RdUserMutation {
	m := &RdUserMutation{
		config:        c,
		op:            op,
		typ:           TypeRdUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRdUserID sets the ID field of the mutation.
func withRdUserID(id int32) rduserOption {
	return func(m *RdUserMutation) {
		var (
			err   error
			once  sync.Once
			value *RdUser
		)
		m.oldValue = func(ctx context.Context) (*RdUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RdUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRdUser sets the old RdUser of the mutation.
func withRdUser(node *RdUser) rduserOption {
	return func(m *RdUserMutation) {
		m.oldValue = func(context.Context) (*RdUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RdUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RdUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RdUser entities.
func (m *RdUserMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RdUserMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RdUserMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RdUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNick sets the "nick" field.
func (m *RdUserMutation) SetNick(s string) {
	m.nick = &s
}

// Nick returns the value of the "nick" field in the mutation.
func (m *RdUserMutation) Nick() (r string, exists bool) {
	v := m.nick
	if v == nil {
		return
	}
	return *v, true
}

// OldNick returns the old "nick" field's value of the RdUser entity.
// If the RdUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdUserMutation) OldNick(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNick is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNick requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNick: %w", err)
	}
	return oldValue.Nick, nil
}

// ResetNick resets all changes to the "nick" field.
func (m *RdUserMutation) ResetNick() {
	m.nick = nil
}

// SetStatus sets the "status" field.
func (m *RdUserMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *RdUserMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RdUser entity.
// If the RdUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdUserMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *RdUserMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *RdUserMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *RdUserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreateTime sets the "create_time" field.
func (m *RdUserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RdUserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the RdUser entity.
// If the RdUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RdUserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RdUserMutation) ResetCreateTime() {
	m.create_time = nil
}

// Where appends a list predicates to the RdUserMutation builder.
func (m *RdUserMutation) Where(ps ...predicate.RdUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RdUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RdUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RdUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RdUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RdUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RdUser).
func (m *RdUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RdUserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.nick != nil {
		fields = append(fields, rduser.FieldNick)
	}
	if m.status != nil {
		fields = append(fields, rduser.FieldStatus)
	}
	if m.create_time != nil {
		fields = append(fields, rduser.FieldCreateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RdUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rduser.FieldNick:
		return m.Nick()
	case rduser.FieldStatus:
		return m.Status()
	case rduser.FieldCreateTime:
		return m.CreateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RdUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rduser.FieldNick:
		return m.OldNick(ctx)
	case rduser.FieldStatus:
		return m.OldStatus(ctx)
	case rduser.FieldCreateTime:
		return m.OldCreateTime(ctx)
	}
	return nil, fmt.Errorf("unknown RdUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RdUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rduser.FieldNick:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNick(v)
		return nil
	case rduser.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case rduser.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	}
	return fmt.Errorf("unknown RdUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RdUserMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, rduser.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RdUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rduser.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RdUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rduser.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown RdUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RdUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RdUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RdUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RdUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RdUserMutation) ResetField(name string) error {
	switch name {
	case rduser.FieldNick:
		m.ResetNick()
		return nil
	case rduser.FieldStatus:
		m.ResetStatus()
		return nil
	case rduser.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	}
	return fmt.Errorf("unknown RdUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RdUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RdUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RdUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RdUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RdUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RdUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RdUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RdUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RdUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RdUser edge %s", name)
}
